{
  "name": "Adaptive RAG Demo - Intelligent Query Routing",
  "nodes": [
    {
      "parameters": {},
      "id": "a1d2a3p4-t5i6-7v8e-9r0a-g1s2e3a4r5c6",
      "name": "Demo Start",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [240, 300]
    },
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "query_factual",
              "value": "What is WAL in PostgreSQL?"
            },
            {
              "name": "query_conceptual", 
              "value": "How does MVCC reduce locking?"
            },
            {
              "name": "query_procedural",
              "value": "Steps to configure WAL archiving"
            },
            {
              "name": "active_query",
              "value": "What is WAL in PostgreSQL?"
            },
            {
              "name": "method",
              "value": "adaptive"
            }
          ],
          "number": [
            {
              "name": "top_k",
              "value": 5
            }
          ]
        },
        "options": {}
      },
      "id": "d2a3p4t5-i6v7-8e9r0-a1g2-s3e4a5r6c7h8",
      "name": "Query Selection",
      "type": "n8n-nodes-base.set",
      "typeVersion": 1,
      "position": [460, 300]
    },
    {
      "parameters": {
        "functionCode": "// Query type detection for demonstration\nconst items_data = items[0].json;\nconst query = items_data.active_query;\n\n// Simple query classification logic\nfunction classifyQuery(query) {\n  const queryLower = query.toLowerCase();\n  \n  // Factual queries - benefit from sparse (exact terms)\n  if (queryLower.includes('what is') || queryLower.includes('define') || queryLower.includes('meaning')) {\n    return {\n      type: 'factual',\n      description: 'Definition/factual query → sparse-heavy weights',\n      expected_routing: 'Sparse-heavy (exact term matching)',\n      predicted_alpha: 0.3\n    };\n  }\n  \n  // Conceptual queries - benefit from dense (semantic)\n  if (queryLower.includes('how does') || queryLower.includes('explain') || queryLower.includes('why')) {\n    return {\n      type: 'conceptual',\n      description: 'Conceptual query → dense-heavy weights', \n      expected_routing: 'Dense-heavy (semantic understanding)',\n      predicted_alpha: 0.7\n    };\n  }\n  \n  // Procedural queries - need exact steps (sparse)\n  if (queryLower.includes('how to') || queryLower.includes('steps') || queryLower.includes('procedure')) {\n    return {\n      type: 'procedural',\n      description: 'Procedural query → sparse-heavy weights',\n      expected_routing: 'Sparse-heavy (step-by-step matching)',\n      predicted_alpha: 0.4\n    };\n  }\n  \n  // Default - exploratory queries\n  return {\n    type: 'exploratory',\n    description: 'Exploratory query → balanced weights',\n    expected_routing: 'Balanced approach',\n    predicted_alpha: 0.5\n  };\n}\n\nconst classification = classifyQuery(query);\n\nconst output = {\n  ...items_data,\n  query_analysis: {\n    query: query,\n    detected_type: classification.type,\n    description: classification.description,\n    expected_routing: classification.expected_routing,\n    predicted_alpha: classification.predicted_alpha,\n    reasoning: `The system detected \"${query}\" as a ${classification.type} query and will route accordingly.`\n  }\n};\n\nreturn [{ json: output }];"
      },
      "id": "a3p4t5i6-v7e8-9r0a-1g2s-e3a4r5c6h7d8",
      "name": "Query Analysis",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [680, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://host.docker.internal:8000/search",
        "options": {
          "headers": {
            "Content-Type": "application/json"
          }
        },
        "bodyParametersUi": {
          "parameter": [
            {
              "name": "query",
              "value": "={{ $json.active_query }}"
            },
            {
              "name": "method",
              "value": "adaptive"
            },
            {
              "name": "top_k",
              "value": "={{ $json.top_k }}"
            },
            {
              "name": "include_metadata",
              "value": "true"
            },
            {
              "name": "include_timing",
              "value": "true"
            }
          ]
        },
        "sendBody": true
      },
      "id": "p4t5i6v7-e8r9-0a1g-2s3e-a4r5c6h7d8i9",
      "name": "Adaptive RAG API",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [900, 300]
    },
    {
      "parameters": {
        "functionCode": "// Combine query analysis with API response\nconst apiResponse = items[0].json;\nconst queryAnalysis = items[0].json.query_analysis;\n\n// Create comprehensive adaptive results\nconst output = {\n  query: apiResponse.query,\n  method: 'adaptive',\n  \n  // Pre-analysis (what we predicted)\n  predicted_analysis: {\n    query_type: queryAnalysis.detected_type,\n    predicted_alpha: queryAnalysis.predicted_alpha,\n    reasoning: queryAnalysis.reasoning\n  },\n  \n  // Actual results (what the API returned)\n  actual_results: {\n    method_used: apiResponse.method_used,\n    alpha_used: apiResponse.alpha,\n    answer: apiResponse.answer,\n    timing_ms: apiResponse.timing?.total_ms || 0,\n    context_count: apiResponse.contexts?.length || 0\n  },\n  \n  // Detailed contexts with scores\n  contexts_detailed: (apiResponse.contexts || []).slice(0, 3).map(ctx => ({\n    title: ctx.title,\n    dense_score: ctx.sd || ctx.sim_dense || 0,\n    sparse_score: ctx.ss || ctx.sim_sparse || 0,\n    hybrid_score: ctx.hybrid || 0,\n    snippet: (ctx.content || '').substring(0, 150) + '...'\n  })),\n  \n  // Analysis comparison\n  analysis_accuracy: {\n    prediction_correct: Math.abs((queryAnalysis.predicted_alpha || 0.5) - (apiResponse.alpha || 0.5)) < 0.2,\n    alpha_difference: Math.abs((queryAnalysis.predicted_alpha || 0.5) - (apiResponse.alpha || 0.5)),\n    note: 'Comparing our prediction vs actual system routing'\n  },\n  \n  success: apiResponse.success,\n  raw_response: apiResponse\n};\n\n// Add visual status\nif (apiResponse.success) {\n  output.status = '🧠 ADAPTIVE SUCCESS';\n  if (output.analysis_accuracy.prediction_correct) {\n    output.prediction_status = '✅ Prediction matched system routing!';\n  } else {\n    output.prediction_status = '🔄 System chose different routing (this is normal)';\n  }\n} else {\n  output.status = '❌ ERROR';\n}\n\nreturn [{ json: output }];"
      },
      "id": "t5i6v7e8-r9a0-1g2s-3e4a-r5c6h7d8i9v0",
      "name": "Analyze Adaptive Results",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1120, 300]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $json.predicted_analysis.query_type }}",
              "operation": "equal",
              "value2": "factual"
            }
          ]
        }
      },
      "id": "i6v7e8r9-a0g1-2s3e-4a5r-c6h7d8i9v0e1",
      "name": "Route by Query Type",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [1340, 300]
    },
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "routing_explanation",
              "value": "📚 FACTUAL QUERY DETECTED\\n\\nThe system identified this as a definition/factual query.\\n\\nOptimal strategy: Sparse-heavy weights\\nReason: Factual queries benefit from exact term matching\\n\\n💡 Try changing to 'query_conceptual' or 'query_procedural' in Query Selection!"
            }
          ]
        }
      },
      "id": "v7e8r9a0-g1s2-3e4a-5r6c-h7d8i9v0e1r2",
      "name": "Factual Query Routing",
      "type": "n8n-nodes-base.set",
      "typeVersion": 1,
      "position": [1560, 200]
    },
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "routing_explanation",
              "value": "🧠 CONCEPTUAL/PROCEDURAL QUERY\\n\\nThe system identified this as requiring semantic understanding or procedural knowledge.\\n\\nOptimal strategy: Dense-heavy or balanced weights\\nReason: These queries benefit from conceptual matching\\n\\n💡 Notice how the system adapts automatically!"
            }
          ]
        }
      },
      "id": "e8r9a0g1-s2e3-4a5r-6c7h-d8i9v0e1r2a3",
      "name": "Other Query Types",
      "type": "n8n-nodes-base.set",
      "typeVersion": 1,
      "position": [1560, 400]
    }
  ],
  "connections": {
    "Demo Start": {
      "main": [
        [
          {
            "node": "Query Selection",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Query Selection": {
      "main": [
        [
          {
            "node": "Query Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Query Analysis": {
      "main": [
        [
          {
            "node": "Adaptive RAG API",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Adaptive RAG API": {
      "main": [
        [
          {
            "node": "Analyze Adaptive Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Analyze Adaptive Results": {
      "main": [
        [
          {
            "node": "Route by Query Type",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route by Query Type": {
      "main": [
        [
          {
            "node": "Factual Query Routing",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Other Query Types",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {},
  "versionId": "1",
  "id": "adaptive-rag-demo-workflow",
  "meta": {
    "created_at": "2025-09-05T10:30:00.000Z",
    "updated_at": "2025-09-05T10:30:00.000Z",
    "instanceId": "n8n-rag-demo"
  },
  "tags": [
    {
      "id": "rag-demo",
      "name": "RAG Demo"
    },
    {
      "id": "adaptive",
      "name": "Adaptive Search"
    },
    {
      "id": "intelligent-routing",
      "name": "Intelligent Routing"
    }
  ]
}