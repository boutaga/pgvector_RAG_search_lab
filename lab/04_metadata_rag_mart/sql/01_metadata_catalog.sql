-- 01_metadata_catalog.sql — pgvector metadata catalog
--
-- This database stores ONLY metadata about the data lake structure.
-- No actual data content lives here — raw data is in Parquet on S3.
--
-- Two enrichment fields per catalog entry:
--   detail_bi    → manual annotation from BI team (business context, refresh cycles, caveats)
--   detail_agent → auto-generated by LLM from schema inspection (stats, patterns, cardinality)
--
-- Both fields are concatenated into metadata_text before embedding.
-- This produces richer vectors than pure schema info alone.

-- =========================================================================
-- TABLE METADATA
-- =========================================================================
CREATE TABLE catalog.table_metadata (
    id                  SERIAL PRIMARY KEY,
    schema_name         VARCHAR(128) NOT NULL,
    table_name          VARCHAR(128) NOT NULL,
    -- Lake location
    lake_path           TEXT,                -- s3://trading-lake/orders.parquet
    file_format         VARCHAR(32) DEFAULT 'parquet',
    -- Schema stats (from Parquet inspection)
    row_count           BIGINT,
    file_size_bytes     BIGINT,
    column_count        INTEGER,
    partition_keys      TEXT[],              -- e.g. {order_date, asset_class}
    -- Business context
    description         TEXT,                -- short description
    detail_bi           TEXT,                -- manual: BI team annotation
    detail_agent        TEXT,                -- auto: LLM-generated insight
    -- Governance
    classification      VARCHAR(32) NOT NULL DEFAULT 'internal'
                        CHECK (classification IN ('public','internal','confidential','restricted')),
    data_owner          VARCHAR(128),
    contains_pii        BOOLEAN DEFAULT FALSE,
    -- Embedding
    metadata_text       TEXT,                -- concatenated text for embedding
    embedding           vector(1024),        -- Voyage finance-2
    --
    created_at          TIMESTAMPTZ DEFAULT NOW(),
    updated_at          TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (schema_name, table_name)
);

-- =========================================================================
-- COLUMN METADATA
-- =========================================================================
CREATE TABLE catalog.column_metadata (
    id                  SERIAL PRIMARY KEY,
    schema_name         VARCHAR(128) NOT NULL,
    table_name          VARCHAR(128) NOT NULL,
    column_name         VARCHAR(128) NOT NULL,
    ordinal_position    INTEGER,
    -- Type info (from Parquet schema)
    data_type           VARCHAR(64),
    arrow_type          VARCHAR(64),         -- pyarrow type (e.g. int64, utf8, timestamp[us])
    is_nullable         BOOLEAN DEFAULT TRUE,
    -- Key info (from domain knowledge, not PG catalog)
    is_primary_key      BOOLEAN DEFAULT FALSE,
    is_foreign_key      BOOLEAN DEFAULT FALSE,
    referenced_schema   VARCHAR(128),
    referenced_table    VARCHAR(128),
    referenced_column   VARCHAR(128),
    -- Statistics (from Parquet metadata / sample)
    n_distinct          BIGINT,
    null_fraction       REAL,
    sample_values       TEXT[],              -- top 5 most common values
    min_value           TEXT,
    max_value           TEXT,
    -- Business context
    column_comment      TEXT,
    detail_bi           TEXT,                -- manual: BI team annotation
    detail_agent        TEXT,                -- auto: LLM-generated insight
    -- Governance
    is_pii              BOOLEAN DEFAULT FALSE,
    classification      VARCHAR(32) NOT NULL DEFAULT 'internal'
                        CHECK (classification IN ('public','internal','confidential','restricted')),
    masking_rule        VARCHAR(32) DEFAULT 'none'
                        CHECK (masking_rule IN ('none','full_mask','partial_mask','hash','redact')),
    -- Embedding
    metadata_text       TEXT,
    embedding           vector(1024),
    --
    created_at          TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (schema_name, table_name, column_name)
);

-- =========================================================================
-- RELATIONSHIP METADATA (logical, inferred from naming + domain knowledge)
-- =========================================================================
CREATE TABLE catalog.relationship_metadata (
    id                  SERIAL PRIMARY KEY,
    source_schema       VARCHAR(128) NOT NULL,
    source_table        VARCHAR(128) NOT NULL,
    source_column       VARCHAR(128) NOT NULL,
    target_schema       VARCHAR(128) NOT NULL,
    target_table        VARCHAR(128) NOT NULL,
    target_column       VARCHAR(128) NOT NULL,
    relationship_type   VARCHAR(32) DEFAULT 'one_to_many'
                        CHECK (relationship_type IN ('one_to_one','one_to_many','many_to_many')),
    join_condition      TEXT,                -- e.g. "orders.instrument_id = instruments.instrument_id"
    -- Embedding
    metadata_text       TEXT,
    embedding           vector(1024),
    --
    created_at          TIMESTAMPTZ DEFAULT NOW()
);

-- =========================================================================
-- KPI PATTERNS (pre-documented analytical patterns)
-- =========================================================================
CREATE TABLE catalog.kpi_patterns (
    id                  SERIAL PRIMARY KEY,
    kpi_name            VARCHAR(256) NOT NULL,
    kpi_description     TEXT NOT NULL,
    domain              VARCHAR(64)
                        CHECK (domain IN ('trading','risk','compliance','portfolio','operations')),
    required_tables     TEXT[] NOT NULL,
    required_columns    TEXT[],
    sql_template        TEXT,                -- reference SQL (runs on lake.* staging tables)
    classification      VARCHAR(32) DEFAULT 'internal',
    -- Embedding
    metadata_text       TEXT,
    embedding           vector(1024),
    --
    created_at          TIMESTAMPTZ DEFAULT NOW()
);

-- =========================================================================
-- VECTOR INDEXES
-- =========================================================================

-- HNSW indexes (pgvector) — good for small-to-medium catalogs
CREATE INDEX idx_table_meta_hnsw ON catalog.table_metadata
    USING hnsw (embedding vector_cosine_ops) WITH (m = 16, ef_construction = 128);

CREATE INDEX idx_column_meta_hnsw ON catalog.column_metadata
    USING hnsw (embedding vector_cosine_ops) WITH (m = 16, ef_construction = 128);

CREATE INDEX idx_rel_meta_hnsw ON catalog.relationship_metadata
    USING hnsw (embedding vector_cosine_ops) WITH (m = 16, ef_construction = 128);

CREATE INDEX idx_kpi_meta_hnsw ON catalog.kpi_patterns
    USING hnsw (embedding vector_cosine_ops) WITH (m = 16, ef_construction = 128);

-- StreamingDiskANN indexes (pgvectorscale) — for production scale
-- Uncomment these for large catalogs (1M+ vectors); HNSW is fine for demo scale
--
-- CREATE INDEX idx_column_meta_diskann ON catalog.column_metadata
--     USING diskann (embedding vector_cosine_ops);

-- =========================================================================
-- LOOKUP INDEXES
-- =========================================================================
CREATE INDEX idx_table_meta_name ON catalog.table_metadata (table_name);
CREATE INDEX idx_column_meta_table ON catalog.column_metadata (table_name, column_name);
CREATE INDEX idx_column_meta_pii ON catalog.column_metadata (is_pii) WHERE is_pii = TRUE;
CREATE INDEX idx_table_meta_class ON catalog.table_metadata (classification);

-- =========================================================================
-- HELPER VIEW
-- =========================================================================
CREATE OR REPLACE VIEW catalog.v_column_relationships AS
SELECT
    c.schema_name, c.table_name, c.column_name, c.data_type,
    c.is_pii, c.classification, c.masking_rule,
    r.target_table AS fk_table, r.target_column AS fk_column,
    r.relationship_type,
    c.detail_bi, c.detail_agent
FROM catalog.column_metadata c
LEFT JOIN catalog.relationship_metadata r
    ON c.table_name = r.source_table AND c.column_name = r.source_column;
