#!/usr/bin/env python3
"""
Pydantic models for MartPlan data structures.
Defines the schema for the JSON output from the mart planning agent.
"""

from pydantic import BaseModel, Field, validator
from typing import List, Dict, Any, Optional
from enum import Enum

class AggregationType(str, Enum):
    """Supported aggregation types for measures."""
    SUM = "sum"
    COUNT = "count"
    AVG = "avg"
    MAX = "max"
    MIN = "min"
    COUNT_DISTINCT = "count_distinct"

class MeasureDefinition(BaseModel):
    """Definition of a measure in a fact table."""
    name: str = Field(..., description="Name of the measure")
    expression: str = Field(..., description="SQL expression for calculating the measure")
    aggregation: AggregationType = Field(..., description="Default aggregation type")
    description: Optional[str] = Field(None, description="Human-readable description")
    data_type: Optional[str] = Field("numeric", description="Expected data type")

    @validator('name')
    def name_must_be_valid_identifier(cls, v):
        if not v.replace('_', '').isalnum():
            raise ValueError('Measure name must be a valid SQL identifier')
        return v

class DimensionDefinition(BaseModel):
    """Definition of a dimension table."""
    name: str = Field(..., description="Name of the dimension")
    source_table: str = Field(..., description="Source table for the dimension")
    key_column: str = Field(..., description="Primary key column")
    attributes: List[str] = Field(..., description="Dimension attributes to include")
    description: Optional[str] = Field(None, description="Human-readable description")

    @validator('name')
    def name_must_be_valid_identifier(cls, v):
        if not v.replace('_', '').isalnum():
            raise ValueError('Dimension name must be a valid SQL identifier')
        return v

class FactDefinition(BaseModel):
    """Definition of a fact table."""
    name: str = Field(..., description="Name of the fact table")
    grain: List[str] = Field(..., description="Grain columns (dimension keys)")
    measures: List[MeasureDefinition] = Field(..., description="Fact table measures")
    dimension_keys: List[str] = Field(..., description="Foreign key columns to dimensions")
    source_tables: List[str] = Field(..., description="Source tables involved")
    join_conditions: List[str] = Field(..., description="SQL join conditions")
    where_conditions: Optional[List[str]] = Field(None, description="Optional filter conditions")
    description: Optional[str] = Field(None, description="Human-readable description")

    @validator('name')
    def name_must_be_valid_identifier(cls, v):
        if not v.replace('_', '').isalnum():
            raise ValueError('Fact table name must be a valid SQL identifier')
        return v

    @validator('grain')
    def grain_must_not_be_empty(cls, v):
        if not v:
            raise ValueError('Fact table must have at least one grain column')
        return v

class IndexDefinition(BaseModel):
    """Definition of an index to create."""
    name: str = Field(..., description="Index name")
    table_name: str = Field(..., description="Table to index")
    columns: List[str] = Field(..., description="Columns to index")
    index_type: str = Field("btree", description="Index type (btree, hash, etc.)")
    is_unique: bool = Field(False, description="Whether index should be unique")

class MartPlan(BaseModel):
    """Complete data mart plan generated by the agent."""
    plan_id: Optional[str] = Field(None, description="Unique identifier for this plan")
    source_schema: str = Field(..., description="Source schema name")
    target_schema: str = Field(..., description="Target mart schema name")

    facts: List[FactDefinition] = Field(..., description="Fact tables to create")
    dimensions: List[DimensionDefinition] = Field(..., description="Dimension tables to create")
    indexes: Optional[List[IndexDefinition]] = Field(None, description="Indexes to create")

    execution_order: Optional[List[str]] = Field(None, description="Order of table creation")
    estimated_rows: Optional[Dict[str, int]] = Field(None, description="Estimated row counts")

    metadata: Optional[Dict[str, Any]] = Field(None, description="Additional metadata")

    class Config:
        """Pydantic configuration."""
        json_encoders = {
            # Add any custom encoders here if needed
        }
        schema_extra = {
            "example": {
                "source_schema": "src_northwind",
                "target_schema": "mart_sales",
                "facts": [
                    {
                        "name": "fact_sales",
                        "grain": ["order_id", "product_id"],
                        "measures": [
                            {
                                "name": "gross_sales",
                                "expression": "unit_price * quantity * (1 - discount)",
                                "aggregation": "sum",
                                "description": "Total sales amount before discounts"
                            }
                        ],
                        "dimension_keys": ["order_date", "product_id", "customer_id"],
                        "source_tables": ["orders", "order_details"],
                        "join_conditions": ["orders.order_id = order_details.order_id"]
                    }
                ],
                "dimensions": [
                    {
                        "name": "dim_product",
                        "source_table": "products",
                        "key_column": "product_id",
                        "attributes": ["product_name", "category_id", "unit_price"]
                    }
                ]
            }
        }

class PlanValidationResult(BaseModel):
    """Result of validating a mart plan."""
    is_valid: bool = Field(..., description="Whether the plan is valid")
    errors: List[str] = Field(default_factory=list, description="Validation errors")
    warnings: List[str] = Field(default_factory=list, description="Validation warnings")
    suggestions: List[str] = Field(default_factory=list, description="Improvement suggestions")

class ExecutionStep(BaseModel):
    """A single step in mart execution."""
    step_number: int = Field(..., description="Step order")
    step_type: str = Field(..., description="Type of step (CREATE_SCHEMA, CREATE_TABLE, etc.)")
    description: str = Field(..., description="Human-readable description")
    sql_statement: str = Field(..., description="SQL to execute")
    depends_on: Optional[List[int]] = Field(None, description="Step numbers this depends on")
    estimated_duration_ms: Optional[int] = Field(None, description="Estimated execution time")

class ExecutionPlan(BaseModel):
    """Complete execution plan for a mart."""
    mart_plan: MartPlan = Field(..., description="The mart plan to execute")
    steps: List[ExecutionStep] = Field(..., description="Execution steps in order")
    total_estimated_duration_ms: Optional[int] = Field(None, description="Total estimated time")

class ExecutionResult(BaseModel):
    """Result of executing a mart plan."""
    execution_id: str = Field(..., description="Unique execution identifier")
    mart_plan: MartPlan = Field(..., description="The executed mart plan")
    status: str = Field(..., description="Execution status")
    steps_completed: int = Field(..., description="Number of steps completed")
    total_steps: int = Field(..., description="Total number of steps")
    error_message: Optional[str] = Field(None, description="Error message if failed")
    execution_time_ms: Optional[int] = Field(None, description="Actual execution time")
    rows_processed: Optional[int] = Field(None, description="Total rows processed")
    tables_created: Optional[int] = Field(None, description="Number of tables created")

    @validator('status')
    def status_must_be_valid(cls, v):
        valid_statuses = ['PLANNING', 'EXECUTING', 'COMPLETED', 'FAILED', 'CANCELLED']
        if v not in valid_statuses:
            raise ValueError(f'Status must be one of: {valid_statuses}')
        return v